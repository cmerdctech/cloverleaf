'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	fs = require('fs');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.ping = qtools.ping;

	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'fileName',
				optional: false
			},
			{
				name: 'outputSpec',
				optional: true
			},
			{
				name: 'config',
				optional: false
			}
		]
	});


	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};

	//LOCAL FUNCTIONS ====================================

	var stripHeaderRow = function(inData, stripHeaderNow) {
		var tmp = inData.split(self.lineEnding);

		delete tmp[0];
		return tmp.join(self.lineEnding).replace(new RegExp("^"+self.lineEnding), '');
	}
	
	var writeOneChunk=function(dataBuffer, startInx, length){
		var inData = dataBuffer.getBufferData(startInx, length),
			flatSpecs = dataBuffer.giveFlatSpecs(),
			data = self.flattener.flattenToString(inData, flatSpecs);

		if (!self.header || self.alreadyKeptOne) {
			data = stripHeaderRow(data);
		} else {
			self.alreadyKeptOne = true;
		}
		
		self.dataBuffer += data;
		qtools.writeSureFile(self.filePath, data, {
			append: true
		});
	}

	//METHODS AND PROPERTIES ====================================

	self.alreadyKeptOne = false;

	this.lineEnding=this.config.runtimeParameters.lineEnding?this.config.runtimeParameters.lineEnding:'\n';

	this.dataBuffer = '';

	if (this.outputSpec.fileFormat == 'tabDelimitted') {
		var tmp = require('objectFlattener');
		this.flattener = new tmp({
			config: this.config
		});
	} else {
		throw "fileWrite.js says, output.fileFormat is wrong, only 'tabDelimitted' supported presently";
	}
	


	this.takeItAway = function(dataBuffer, fileWriteCallback) {

		var	rowCount=dataBuffer.getBufferData().length;

		
		append = qtools.strToBool(append);
		header = qtools.strToBool(header);

		var enhancedCallback = function(err, result) {
			result = result ? result : {
					targetDataId: self.filePath,
					summaryString: rowCount.toString() + ' rows'
				}


			global.localEnvironment.log.info({
				source: 'fileWriter.js',
				type: 'finalInfo',
				evidence: result
			});

			fileWriteCallback(err, result);
		}
		
		var chunkSize=100;
		for (var i=0, len=rowCount; i<len; i=i+chunkSize){
			writeOneChunk(dataBuffer, i, chunkSize);
		}

		enhancedCallback();

	}

	//INITIALIZATION ====================================
	
		var header = qtools.getSurePath(self.outputSpec || {}, "context.header"),
			parentPath = qtools.getSurePath(self.outputSpec || {}, "context.parentPath"),
			extension = qtools.getSurePath(self.outputSpec || {}, "context.fileExtension"),
			append = qtools.getSurePath(self.outputSpec || {}, "context.append");			
		parentPath = parentPath ? parentPath : '';
		extension = extension ? extension : '';

		self.filePath = parentPath + self.fileName+extension;
		self.append=append;
		self.header=header;
	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;

